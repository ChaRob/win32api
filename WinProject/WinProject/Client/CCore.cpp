#include "pch.h"
#include "CCore.h"
#include "CKeyMgr.h"
#include "CTimeMgr.h"

CObject g_object;

CCore::CCore():
	m_hwnd(0),
	m_ptResolution{},
	m_hDC(0){}
CCore::~CCore()
{
	ReleaseDC(m_hwnd, m_hDC);
}

int CCore::Init(HWND _hwnd, POINT _ptResolution)
{
	m_hwnd = _hwnd;
	m_ptResolution = _ptResolution;

	// 해상도에 맞게 윈도우 크기 조절
	// window 7, 10에 따라서 경게(border)가 다르기에 지정한 해상도가 나오도록 잡아준다.
	RECT rt = {0, 0, m_ptResolution.x, m_ptResolution.y};
	AdjustWindowRect(
		&rt, /* LPRECT, 곧 RECT*를 의미. 함수가 종료되면 rt에 저장된 값을 접근해서 수정해줌. */
		WS_OVERLAPPEDWINDOW, /* 자주 쓰는 윈도우 세팅을 합쳐둔 것 */
		TRUE);
	SetWindowPos(m_hwnd, nullptr, 100, 100, rt.right - rt.left, rt.bottom - rt.top, 0);

	// Device Context 초기화 및 호출
	// 메세지 기반 방식이 아닌, 우리가 원할 때 그림을 그릴 수 있도록 설정함.
	m_hDC = GetDC(m_hwnd);

	g_object.SetPos(Vector2( m_ptResolution.x / 2, m_ptResolution.y / 2 ));
	g_object.SetScale(Vector2 {100, 100 });

	// Manager 초기화
	CKeyMgr::GetInstance()->Init();
	CTimeMgr::GetInstance()->Init();

	return S_OK;
}

void CCore::Progress()
{
	// Manager Update
	CTimeMgr::GetInstance()->Update();

	Update();
	Render();
}

void CCore::Update()
{
	// 비동기 키 입출력 함수
	// 윈도우가 활성화되어 있지 않아도 동작하기 때문에, 신경써야함.
	Vector2 newPos = g_object.GetPos();

	if (GetAsyncKeyState(VK_LEFT) & 0x8000) // 눌렸는지 체크하는 방식.
	{
		// 컴퓨터 설정에 따라서 호출하는 함수의 횟수가 다르기 때문에,
		// 숫자값을 조정하는 것으로는 해결하는게 말이 되지 않는다.
		// 멀티플레이 게임을 생각해보자.
		// 따라서 모든 컴퓨터의 성능에 상관없이, 일정한 함수 호출(또는 이동량)을 보장해야 한다.
		newPos.x -= 10 * DeltaTime;
	}
	if (GetAsyncKeyState(VK_RIGHT) & 0x8000) // 눌렸는지 체크하는 방식.
	{
		newPos.x += 10 * DeltaTime;
	}
	if (GetAsyncKeyState(VK_UP) & 0x8000) // 눌렸는지 체크하는 방식.
	{
		newPos.y -= 10 * DeltaTime;
	}
	if (GetAsyncKeyState(VK_DOWN) & 0x8000) // 눌렸는지 체크하는 방식.
	{
		newPos.y += 10 * DeltaTime;
	}

	g_object.SetPos(newPos);
}

void CCore::Render()
{
	// 그리기 작업
	// 게임 화면이라는 것은 매순간마다 계속 변화하는 과정.
	// 한 장면을 그리고 보여주고, 뒤에서 새로 그린 것을 다시 대체해서 보여주고...반복

	Vector2 vPos = g_object.GetPos();
	Vector2 vScale = g_object.GetScale();

	Rectangle(m_hDC, 
		int(vPos.x - vScale.x / 2.f),
		int(vPos.y - vScale.y / 2.f),
		int(vPos.x + vScale.x / 2.f),
		int(vPos.y + vScale.y / 2.f));
}
